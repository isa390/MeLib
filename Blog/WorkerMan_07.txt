<br>2022-06-01 22:23:47:注意：在线程之间传递对象时要小心。最好通过处理程序消息传递 Surface 或 SurfaceHolder（而不仅仅是将其填充到线程中），避免多核系统出现问题。如需了解详情，请参阅 SMP Primer for Android。<br><br>2022-06-01 22:22:42:在 Activity 启动/停止时启动/停止线程可与应用生命周期良好配合。您可以在 onResume() 中启动渲染程序线程，并在 onStop() 中停止渲染程序线程。创建和配置线程时，有时 Surface 已经存在，有时不存在（例如，在使用电源按钮关闭屏幕后，Surface 仍处于活动状态）。您必须先等待 Surface 完成创建，然后再在线程中进行初始化。您不能在 surfaceCreate() 回调中初始化，因为如果未重新创建 Surface，它将不会再次触发。您需要改为查询或缓存 surface 状态，并将其转发到渲染器线程。<br><br>2022-06-01 22:21:46:如果您点按电源按钮锁屏，只会出现 onPause()（没有 surfaceDestroyed()）。Surface 仍处于活动状态，并且可以继续渲染。如果您继续请求，则可以持续获得 Choreographer 事件。如果锁屏会强制改变方向，则当设备解锁时，您的 Activity 可能会重启。否则，您可以在脱离锁屏状态后使用与之前相同的 Surface。  线程的生命周期可以与 Surface 或 Activity 相关联，具体取决于锁屏时您想要发生的情况。该线程可以在 Activity 启动/停止时或者在 Surface 创建/销毁时启动/停止。<br><br>2022-06-01 22:17:54:如果，这个回调接口设置到了一个静态对象（单例模式），当 activity finish() 的时候（按返回键，回到桌面），则activity 不会被调用 onDestroy() ，原因可能是 activity 对象还在被引用！  此时你再点击图标回到应用，onCreate() 再次调用！  很明显，如果你把资源释放放在了 onDestroy() 里面，就会导致内存泄露！   那有没有解决办法呢？有的  你可以在 onPause() 方法里面判断 isFinishing() ，正常调用 finish() 后 activity 的回调过程是 onPause、onStop、onDestroy ，倘若出现上面的情况，只到 onPause！但是 isFinishing() 标志还是为 true ！你可以释放资源了。<br>