<br>2022-05-20 20:26:23:么该下拉刷新组件将拦截触摸事件，然后根据用户的触摸事件获取到手指滑动的y  轴距离，并通过Scroller将该下拉刷新组件在y  轴上滚动手指滑动的距离，实现HeaderView显示与隐藏，从而到达下拉的效果，如图2-18所示。当用户滑动到最底部时会触发加载更多的操作，此时会通过Scroller滚动该下拉刷新组件，将Footer View显示出来，实现加载更多的效果<br><br>2022-05-20 20:25:31:自定义ViewGroup是另一种重要的自定义View形式，当我们需要自定义子视图的排列方式时，通常需要通过这种形式实现。例如，最常用的下拉刷新组件，实现下拉刷新、上拉加载更多的原理就是自定义一个ViewGroup，将Header View、Content View、Footer View从上到下依次布局，如图2-16所示（红色区域为屏幕的显示区域运行时可看到色彩）。然后在初始时通过Scroller滚动使得该组件在y轴方向上滚动HeaderView的高度，这样当依赖该ViewGroup显示在用户眼前时HeaderView就被隐藏掉了，如图2-17所示。而Content View的宽度和高度都是match_parent的，因此，此时屏幕上只显示Content View，HeaderView和FooterView都被隐藏在屏幕之外。当Content View被滚动到顶部，此时<br><br>2022-05-20 19:48:45:自定义View也有几种实现类型，分别为继承自View完全自定义、继承自现有控件（如ImageView）实现特定效果、继承自ViewGroup实现布局类，在这其中比较重要的知识点是View的测量与布局、View的绘制、处理触摸事件、动画等，也就是本章我们要学习的重要知识点。<br><br>2022-05-20 19:25:26:使用ContentProvider对外共享数据的好处是，统一了数据的访问方式，它实际上是对SQliteOpenHelper的进一步封装，通过Uri映射来判断选择需要操作数据库中的哪个表，并且进行增、删、改、查处理。 首先我们先来学习Uri，Uri代表了要操作的数据表的绝对路径，Uri主要包含了两部分信息，一是需要操作的ContentProvider，二是对ContentProvider中的哪个表进行操作。对于ContentProvider来说，一个Uri由以下几部分组成，如图1-18所示。<br><br>2022-05-20 19:17:47:我们在onCreate函数中调用了showNotification函数显示通知，并且在最后调用startForeground将服务设置为前台服务<br><br>2022-05-20 19:16:03:IntentService 完成一个简单的后台任务需要这么麻烦，Android显然早就“洞察”了这一点。因此，提供了一个IntentService来完成这样的操作，IntentService将用户的请求执行在一个子线程中，用户只需要覆写onHandleIntent函数，并且在该函数中完成自己的耗时操作即可。需要注意的是，在任务执行完毕之后IntentService会调用stopSelf自我销毁，因此，它适用于完成一些短期的耗时任务。示<br><br>2022-05-20 19:11:09:Service是Android中实现程序后台运行的解决方案，它非常适合用于去执行那些不需要和用户交互而且还要求长期运行的任务。<br><br>2022-05-20 19:00:05:ingleTop 如果一个以singleTop模式启动的Activity的实例已经存在于任务栈的栈顶，那么再启动这个Activity时，不会创建新的实例，而是重用位于栈顶的那个实例，并且会调用该实例的onNewIntent()函数将Intent对象传递到这个实例中。例<br><br>2022-05-20 18:43:21:onPause() 这个函数在系统准备去启动或者恢复另一个Activity时调用，也就是在Activity即将从可见状态变为不可见时。我们通常会在这个函数中将一些消耗CPU的资源释放掉，以及保存一些关键数据。<br><br>2022-05-20 18:42:52:Activity就会请求AMS渲染它所管理的视图。此时的Activity一定位于返回栈的栈顶，并且处于运行状态。<br><br>2022-05-20 18:42:14:．onCreate() 相信这是开发者见过次数最多的函数，我们在创建继承自Activity的类时都会默认生成这个函数。它会在Activity第一次被创建时调用，通常会在这个函数中完成Activity的初始化操作，如设置布局、初始化视图、绑定事件等。<br>