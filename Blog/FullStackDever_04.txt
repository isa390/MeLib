<br>2022-05-18 11:05:06:CompletionService实现并行调用  对于上面的例子，如何实现并行调用呢?  有小伙伴说，可以使用Future+Callable实现多个任务的并行调用。但是线程池执行批量任务时，返回值用Future的get()获取是阻塞的，如果前一个任务执行比较耗时的话，get()方法会阻塞，形成排队等待的情况。  而CompletionService是对定义ExecutorService进行了包装，可以一边生成任务,一边获取任务的返回值。让这两件事分开执行,任务之间不会互相阻塞，可以获取最先完成的任务结果。  CompletionService的实现原理比较简单，底层通过FutureTask+阻塞队列，实现了任务先完成的话，可优先获取到。也就是说任务执行结果按照完成的先后顺序来排序，先完成可以优先获取到。内部有一个先进先出的阻塞队列，用于保存已经执行完成的Future，你调用CompletionService的poll或take方法即可获取到一个已经执行完成的Future，进而通过调用Future接口实现类的get方法获取最终的结果。<br>